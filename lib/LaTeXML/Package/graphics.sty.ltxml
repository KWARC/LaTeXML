# -*- CPERL -*-
# /=====================================================================\ #
# |  graphics                                                           | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
#**********************************************************************
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;
use LaTeXML::Util::Pathname;

#**********************************************************************
# (See  LaTeXML::Post::Graphics for suggested postprocessing)
# Package options: draft, final, hiderotate, hidescale, hiresbb

DefParameterType('GraphixDimension', sub {
    my ($gullet) = @_;
    if ($gullet->ifNext(T_OTHER('!'))) {
      $gullet->readToken();
      Dimension(0); }
    else {
      $gullet->readDimension; } });

# Use CSS transforms to achieve these
DefConstructor('\scalebox{}[] Digested', sub {
    my ($document, $xscale, $yscale, $box, %props) = @_;
    my $scale;
    insertBlock($document, $box,
      cssstyle => $props{transform},
      # Should we put the dimensions on attributes?
      # width=>$props{width},
      # height=>$props{height},
      # depth=>$props{depth}
      ); },
  properties => sub {
    my ($stomach, $xscale, $yscale, $box) = @_;
    $xscale = ToString($xscale);
    $yscale = ($yscale ? ToString($yscale) : $xscale);
    my $transform = 'transform:scale(' . $xscale . ',' . $yscale . ');';
    my ($w, $h, $d) = $box->getSize;
    (($w ? (width => $w->multiply($xscale)) : ()),
      ($h      ? (height => $h->multiply($yscale)) : ()),
      ($d      ? (depth  => $d->multiply($yscale)) : ()),
      ($xscale ? (xscale => $xscale)               : ()),
      ($yscale ? (yscale => $yscale)               : ()),
      transform => $transform); },
  mode => 'text');

DefConstructor('\resizebox OptionalMatch:* {GraphixDimension}{GraphixDimension} Digested', sub {
    my ($document, $star, $width, $height, $box, %props) = @_;
    insertBlock($document, $box,
      width  => $props{width},
      height => $props{height},
      depth  => $props{depth}); },    # ?
  properties => sub {
    my ($stomach, $star, $width, $height, $box) = @_;
    (($width ? (width => $width) : ()),
      ($height ? (height => $height) : ()),
      depth => Dimension(0)); },      # ?
  mode => 'text');

DefConstructor('\rotatebox{Float} Digested', sub {
    my ($document, $angle, $box, %props) = @_;
    insertBlock($document, $box,
      cssstyle => $props{transform},
      width    => $props{width},
      #                height=>$props{height},
      #                depth=>$props{depth}
      ); },    # ?
  properties => sub {
    my ($stomach, $angle, $box) = @_;
    my ($w, $h, $d) = map { $_->valueOf } $box->getSize;
    $h += $d;
    $angle = -$angle->valueOf;
    my $rad    = $angle * 3.1415926 / 180;      # close enough
    my $s      = sin($rad);
    my $c      = cos($rad);
    my $ww     = abs($w * $c) + abs($h * $s);
    my $hh     = abs($h * $c) + abs($w * $s);
    my $width  = Dimension($ww);
    my $height = Dimension($hh);
#                 my $transform = 'transform:translate('.2*$width->pxValue.'px,0) rotate('.$angle.'deg) ;';
    my $transform = 'transform:rotate(' . $angle . 'deg) ;';
    (width => $width,
      height    => $height,
      depth     => Dimension(0),
      angle     => $angle,
      transform => $transform); },

  mode => 'text');

DefConstructor('\reflectbox Digested', sub {
    my ($document, $box, %props) = @_;
    insertBlock($document, $box,
      cssstyle => $props{transform},
      # Should we put the dimensions on attributes?
      # width=>$props{width},
      # height=>$props{height},
      # depth=>$props{depth}
      ); },
  properties => sub {
    my ($stomach, $box) = @_;
    my $transform = 'transform:scale(-1,1);';
    my ($w, $h, $d) = $box->getSize;
    (transform => $transform); },
  mode => 'text');

DefConstructor('\graphicspath DirectoryList', sub {
    my ($document, $paths) = @_;
    foreach my $dir ($paths->getValues) {
      my $path = pathname_absolute(pathname_canonical(ToString($dir)));
      print STDERR "GOT PATH: " . $path . "\n";
      $document->insertPI('latexml', graphicspath => $path); } });

# Basically, we're transforming the graphics options into graphicx format.
DefMacro('\includegraphics OptionalMatch:* [][] Semiverbatim',
  '\@includegraphics#1[#2][#3]{#4}');

DefConstructor('\@includegraphics OptionalMatch:* [][] Semiverbatim', sub {
    my ($document, $starred, $op1, $op2, $graphic) = @_;
    my $bb = ($op2 ? ToString($op1) . " " . ToString($op2) : ($op1 ? "0 0 " . ToString($op1) : ''));
    $bb =~ s/,/ /g;
    my $options = ($starred ? ($bb ? "viewport=$bb, clip" : "clip") : '');
    $graphic = ToString($graphic); $graphic =~ s/^\s+//; $graphic =~ s/\s+$//;
    my @candidates = pathname_findall($graphic, types => ['*'], paths => LookupValue('GRAPHICSPATHS'));
    if (my $base = LookupValue('SOURCEDIRECTORY')) {
      @candidates = map { pathname_relative($_, $base) } @candidates; }
    $document->insertElement('ltx:graphics', undef, graphic => $graphic, options => $options,
      candidates => join(',', @candidates)); },
  alias => '\includegraphics');

# Also unimplemented... probably nothing useful to pass thru anyway?
DefConstructor('\DeclareGraphicsExtensions{}',          '');
DefConstructor('\DeclareGraphicsRule{}{}{} Undigested', '');
# Nothing done about the keyval package...
#**********************************************************************
1;

